/*
* Autogenerated header by File Header Comment extension - Donna Iwan
* File:       idea_controller.dart
* Created on: Thu Mar 30 2023
* Author:     Tong Vu Than Dan
*
* Copyright (c) 2023 Tong Vu Than Dan
* Website:     dantopia.vn
*
* Description: This file is a place to manage idea with riverpod
 */
import 'package:flutter/foundation.dart';
import 'package:innovation_hub/app/model/component_model.dart';
import 'package:innovation_hub/app/model/idea_model.dart';
import 'package:innovation_hub/app/provider/project_provider.dart';
import 'package:innovation_hub/app/shared/user.dart';
import 'package:innovation_hub/utils/app_utils.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../model/project_model.dart';

part 'idea_controller.g.dart';

@Riverpod(
  keepAlive: true,
)
class IdeaManage extends _$IdeaManage {
  @override
  Idea? build() => null;

  ///Set activie idea with [idea]
  void setIdea(Idea? idea) {
    state = idea;
  }

  Idea? create(Project ofProject, Component withComponent, SITTechniques using) {
    switch (using) {
      case SITTechniques.taskUnification:
        // TODO: Handle this case.
        return null;
      case SITTechniques.substraction:
        return _createIdeaWithSubstractionTechnique(ofProject, withComponent);
      // final concept = "Imagine you have a new ${ofProject.type} '${ofProject.name}' without the '${withComponent.name}'";
      // final idea = Idea(
      //   id: AppUtilities.getUid(),
      //   concept: concept,
      //   name: '',
      //   rating: 1,
      //   benefit: 3,
      //   method: SITTechniques.substraction,
      //   componentId: withComponent.id,
      //   attributeIds: [],
      //   createdAt: AppUtilities.getTimeStampFromNow(),
      //   createdBy: User.demoUser1,
      // );

      // // check if this idea is already generated
      // final ideaList = ref.read(ideasProvider);
      // for (final id in ideaList) {
      //   if (id.concept.contains(idea.concept)) {
      //     debugPrint('Skip this concept');
      //     return null; // Skip the idea
      //   }
      // }
      // // else, update to the list
      // // state = idea;
      // addIdeaToList(idea);
      // return idea;
      case SITTechniques.multiplication:
        // TODO: Handle this case.
        return null;
      case SITTechniques.division:
        // TODO: Handle this case.
        return null;
      case SITTechniques.attributeDependency:
        // TODO: Handle this case.
        return null;
    }
  }

  Idea? _createIdeaWithSubstractionTechnique(Project ofProject, Component withComponent) {
    final concept = "Imagine you have a new ${ofProject.type} '${ofProject.name}' without the '${withComponent.name}'";
    final idea = Idea(
      id: AppUtilities.getUid(),
      concept: concept,
      name: '',
      rating: 1,
      benefit: 3,
      method: SITTechniques.substraction,
      componentId: withComponent.id,
      attributeIds: [],
      createdAt: AppUtilities.getTimeStampFromNow(),
      createdBy: User.demoUser1,
    );

    // check if this idea is already generated
    final ideaList = ref.read(ideasProvider);
    for (final id in ideaList) {
      if (id.concept.contains(idea.concept)) {
        debugPrint('Skip this concept');
        return null; // Skip the idea
      }
    }
    // else, update to the list
    // state = idea;
    addIdeaToList(idea);
    return idea;
  }

  void generateIdeasUsingSIT(SITTechniques technique, bool isInternal) {
    final activeProject = ref.watch(activeProjectProvider);
    List<Component> components = [];
    if (isInternal) {
      components = activeProject.components.where((comp) => comp.isInternal == true).toList();
    } else {
      components = activeProject.components.where((comp) => comp.isInternal == false).toList();
    }
    for (final component in components) {
      final idea = ref.read(ideaManageProvider.notifier).create(
            activeProject,
            component,
            SITTechniques.substraction,
          );
      if (idea != null) {
        debugPrint('ðŸŒŸ Idea generared: ${idea.concept}\n');
      }
    }
  }

  ///Update the idea
  void update(Idea idea) {
    state = state?.copyWith(
      id: idea.id,
      name: idea.name,
      rating: idea.rating,
      benefit: idea.benefit,
      method: idea.method,
      componentId: idea.componentId,
      attributeIds: idea.attributeIds,
      createdAt: idea.createdAt,
      createdBy: idea.createdBy,
    );
    ref.read(ideasProvider.notifier).update(idea);
  }

  /// Read idea with [fromId]
  /// return: read idea
  /// if not found, return null
  Idea? read(String fromId) {
    return null;
  }

  /// If idea is liked, it will save to project ideas
  /// return:
  ///  - true : idea is added
  ///  - false: idea is not added, due to already added
  void ratingIdea(Idea idea, double rating) {
    idea.rating = rating.toInt();
    ref.read(ideasProvider.notifier).update(idea);
  }

  void addIdeaToList(Idea idea) {
    // final project = ref.watch(activeProjectProvider);
    debugPrint('ðŸ˜Ž ðŸ‘‰ Add idea to list of idea');
    // project.ideas?.add(idea);
    ref.read(ideasProvider.notifier).addIdea(idea);
  }

  void updateIdeaInList(Idea idea) {
    ref.read(ideasProvider.notifier).update(state!);
  }

  void removeIdeaFromList(Idea idea) {
    ref.read(ideasProvider.notifier).removeIdea(state!.id);
  }
}

@Riverpod(keepAlive: true)
class Ideas extends _$Ideas {
  @override
  List<Idea> build() {
    return ref.watch(activeProjectProvider).ideas;
  }

  void addIdea(Idea idea) {
    // Since our state is immutable, we are not allowed to do `state.add(idea)`.
    // Instead, we should create a new list of todos which contains the previous
    // items and the new one.
    // Using Dart's spread operator here is helpful!
    state = [
      ...state,
      idea,
    ];
    //Update to project
    ref.read(activeProjectProvider).ideas = state;
  }

  void update(Idea withIdea) {
    final ideaMap = withIdea.toMap();
    state = [
      for (final idea in state)
        if (idea.id == withIdea.id) Idea.fromMap(ideaMap) else idea
    ];
    ref.read(activeProjectProvider).ideas = state;
  }

  void removeIdea(String ideaId) {
    state = state.where((idea) => idea.id != ideaId).toList();
    ref.read(activeProjectProvider).ideas = state;
  }
}

@riverpod
int ideaIndex(IdeaIndexRef ref) {
  return throw UnimplementedError();
}
